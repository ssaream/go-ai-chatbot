<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>AI Chatbot MVP</title>
  <style>
    body { font-family: system-ui, Arial; margin: 0; background: #f6f8fb; }
    .layout { max-width: 1300px; margin: 10px auto; padding: 0 12px; display: grid; grid-template-columns: 2fr 1fr; gap: 12px; min-height: calc(100vh - 20px); }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 14px; background: #fff; }
    .chat-card { display: flex; flex-direction: column; min-height: calc(100vh - 24px); }
    .meta { display:flex; gap:10px; flex-wrap: wrap; align-items:center; margin-bottom: 10px; color:#555; font-size: 13px; }
    code { background: #f2f2f2; padding: 2px 6px; border-radius: 6px; }
    .status-wrap { display:grid; grid-template-columns: repeat(3,1fr); gap:8px; margin-bottom: 10px; }
    .status { border:1px solid #ddd; border-radius: 10px; padding:8px; font-size:12px; }
    .ok { border-color: #17a34a; color: #146c35; background: #eefaf1; }
    .bad { border-color: #cc3344; color: #a82331; background: #fff1f3; }
    .config-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px; }
    .field { display: flex; flex-direction: column; gap: 6px; }
    .field.full { grid-column: 1 / -1; }
    .field label { font-size: 12px; color: #555; }
    .field input, select, textarea { border: 1px solid #ddd; border-radius: 10px; padding: 10px; }
    .hint { font-size: 12px; color: #666; margin-bottom: 10px; }
    #chatLog { flex: 1; min-height: 260px; overflow: auto; border: 1px solid #eee; border-radius: 12px; padding: 12px; background: #fafafa; }
    .msg { margin: 10px 0; padding: 10px 12px; border-radius: 12px; max-width: 85%; white-space: pre-wrap; }
    .user { background: #e8f0fe; margin-left: auto; }
    .bot  { background: #fff; border: 1px solid #eee; }
    .row { display: flex; gap: 10px; margin-top: 12px; position: sticky; bottom: 0; background: #fff; padding-top: 8px; }
    textarea { flex: 1; resize: vertical; min-height: 72px; max-height: 200px; }
    button { padding: 8px 12px; border-radius: 10px; border: 1px solid #ddd; background: #111; color: #fff; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    .side-log { height: calc(100vh - 120px); overflow:auto; background:#0f172a; color:#dbeafe; border-radius:10px; padding:10px; font-size:12px; }
    .line { margin-bottom: 8px; border: 1px solid rgba(255,255,255,0.15); border-radius: 8px; padding: 8px; white-space: pre-wrap; }
    .line .title { font-weight: 700; margin-bottom: 4px; }
    .line .meta { margin: 0; color: #cbd5e1; }
    .line pre { margin: 6px 0 0; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; color: #e2e8f0; }
    @media (max-width: 900px) { .layout { grid-template-columns: 1fr; min-height: auto; } .chat-card { min-height: auto; } .side-log { height: 260px; } }
  </style>
</head>
<body>
  <div class="layout">
    <div class="card chat-card">
      <h2>AI Chatbot MVP</h2>
      <div class="meta">
        <div>Cookie ID: <code id="cookieId">...</code> <button id="newSession" type="button">New cookie/session</button></div>
        <div>Session ID: <code id="sid">...</code></div>
        <div>Conversation ID: <code id="conversationId">...</code> <button id="newConversation" type="button">New conversation</button></div>
      </div>

      <div class="status-wrap">
        <div id="backendStatus" class="status bad">Backend: checking...</div>
        <div id="aiStatus" class="status bad">AI: checking...</div>
        <div id="supabaseStatus" class="status bad">Supabase: checking...</div>
      </div>

      <div class="config-grid">
        <div class="field full">
          <label for="supabaseUrl">Supabase URL</label>
          <input id="supabaseUrl" type="text" placeholder="https://your-project.supabase.co" autocomplete="off"/>
        </div>
        <div class="field">
          <label for="supabaseKey">Supabase Service Role Key</label>
          <input id="supabaseKey" type="password" placeholder="service_role key" autocomplete="off"/>
        </div>
        <div class="field">
          <label for="openaiKey">OpenAI API Key</label>
          <input id="openaiKey" type="password" placeholder="sk-..." autocomplete="off"/>
        </div>
      </div>
      <div class="hint">Config is saved in localStorage. Models auto-load and default to gpt-5-mini when available.</div>

      <div class="field">
        <label for="model">OpenAI Model (chat)</label>
        <div style="display:flex; gap:8px; align-items:center;">
          <select id="model" style="flex:1;"></select>
          <button id="refreshModels" type="button">â†»</button>
        </div>
      </div>

      <div id="chatLog"></div>

      <div class="row">
        <textarea id="input" placeholder="Type your message... (Enter to send, Shift+Enter for newline)"></textarea>
        <button id="send">Send</button>
      </div>
    </div>

    <div class="card">
      <h3>Event log</h3>
      <div id="eventLog" class="side-log"></div>
    </div>
  </div>

<script>
const STORAGE_KEYS = {
  supabaseUrl: "chatbot.supabaseUrl",
  supabaseKey: "chatbot.supabaseServiceRoleKey",
  openaiKey: "chatbot.openaiApiKey",
  model: "chatbot.openaiModel",
};

const chatLog = document.getElementById("chatLog");
const eventLog = document.getElementById("eventLog");
const input = document.getElementById("input");
const sendBtn = document.getElementById("send");
const modelSel = document.getElementById("model");
const refreshModelsBtn = document.getElementById("refreshModels");
const sidEl = document.getElementById("sid");
const cookieIdEl = document.getElementById("cookieId");
const convEl = document.getElementById("conversationId");
const newSessionBtn = document.getElementById("newSession");
const newConversationBtn = document.getElementById("newConversation");
const supabaseUrlInput = document.getElementById("supabaseUrl");
const supabaseKeyInput = document.getElementById("supabaseKey");
const openaiKeyInput = document.getElementById("openaiKey");
const backendStatus = document.getElementById("backendStatus");
const aiStatus = document.getElementById("aiStatus");
const supabaseStatus = document.getElementById("supabaseStatus");

const CHAT_ROLES = new Set(["user", "assistant"]);

function clearChat() {
  chatLog.innerHTML = "";
}

function normalizeRole(role) {
  if (role === "assistant") return "bot";
  if (role === "user") return "user";
  return "bot";
}

function prettyJSON(value) {
  if (value === undefined) return "-";
  if (typeof value === "string") return value;
  try {
    return JSON.stringify(value, null, 2);
  } catch {
    return String(value);
  }
}

function logEvent(entry) {
  const line = document.createElement("div");
  line.className = "line";
  const ts = `[${new Date().toLocaleTimeString()}]`;

  if (typeof entry === "string") {
    line.textContent = `${ts} ${entry}`;
    eventLog.prepend(line);
    return;
  }

  const status = entry?.status || "info";
  const title = entry?.title || "event";
  const inputText = prettyJSON(entry?.input);
  const outputText = prettyJSON(entry?.output);
  const schemaText = prettyJSON(entry?.schema);

  const titleEl = document.createElement("div");
  titleEl.className = "title";
  titleEl.textContent = `${ts} [${status.toUpperCase()}] ${title}`;

  const inputLabel = document.createElement("div");
  inputLabel.className = "meta";
  inputLabel.textContent = "input";
  const inputPre = document.createElement("pre");
  inputPre.textContent = inputText;

  const outputLabel = document.createElement("div");
  outputLabel.className = "meta";
  outputLabel.textContent = "output";
  const outputPre = document.createElement("pre");
  outputPre.textContent = outputText;

  const schemaLabel = document.createElement("div");
  schemaLabel.className = "meta";
  schemaLabel.textContent = "output schema";
  const schemaPre = document.createElement("pre");
  schemaPre.textContent = schemaText;

  line.append(titleEl, inputLabel, inputPre, outputLabel, outputPre, schemaLabel, schemaPre);
  eventLog.prepend(line);
}

function addMsg(text, who) {
  const div = document.createElement("div");
  div.className = `msg ${who}`;
  div.textContent = text;
  chatLog.appendChild(div);
  chatLog.scrollTop = chatLog.scrollHeight;
}

function setStatus(el, label, ok, err = "") {
  el.className = `status ${ok ? "ok" : "bad"}`;
  el.textContent = err ? `${label}: ${ok ? "connected" : "error"} (${err})` : `${label}: ${ok ? "connected" : "error"}`;
}

function saveConfig() {
  localStorage.setItem(STORAGE_KEYS.supabaseUrl, supabaseUrlInput.value.trim());
  localStorage.setItem(STORAGE_KEYS.supabaseKey, supabaseKeyInput.value.trim());
  localStorage.setItem(STORAGE_KEYS.openaiKey, openaiKeyInput.value.trim());
  localStorage.setItem(STORAGE_KEYS.model, modelSel.value);
}

function loadConfig() {
  supabaseUrlInput.value = localStorage.getItem(STORAGE_KEYS.supabaseUrl) || "";
  supabaseKeyInput.value = localStorage.getItem(STORAGE_KEYS.supabaseKey) || "";
  openaiKeyInput.value = localStorage.getItem(STORAGE_KEYS.openaiKey) || "";
}

function buildConfigHeaders() {
  const headers = {};
  if (supabaseUrlInput.value.trim()) headers["X-Supabase-Url"] = supabaseUrlInput.value.trim();
  if (supabaseKeyInput.value.trim()) headers["X-Supabase-Service-Role-Key"] = supabaseKeyInput.value.trim();
  if (openaiKeyInput.value.trim()) headers["X-OpenAI-Api-Key"] = openaiKeyInput.value.trim();
  return headers;
}

async function refreshStatus() {
  try {
    const resp = await fetch("/status", { headers: buildConfigHeaders() });
    const j = await resp.json();
    setStatus(backendStatus, "Backend", !!j.backend?.connected);
    setStatus(aiStatus, "AI", !!j.ai?.connected, j.ai?.error || "");
    setStatus(supabaseStatus, "Supabase", !!j.supabase?.connected, j.supabase?.error || "");
    logEvent({ status: "ok", title: "status check", input: "connectivity", output: `backend=${!!j.backend?.connected}, ai=${!!j.ai?.connected}, supabase=${!!j.supabase?.connected}` });
  } catch (e) {
    setStatus(backendStatus, "Backend", false, e.message);
    setStatus(aiStatus, "AI", false, "status unavailable");
    setStatus(supabaseStatus, "Supabase", false, "status unavailable");
    logEvent({ status: "error", title: "status check", input: "connectivity", output: e.message });
  }
}

async function loadModels() {
  const fallback = ["gpt-5-mini", "gpt-5", "gpt-4.1-mini", "gpt-4o-mini", "o4-mini"];
  const saved = localStorage.getItem(STORAGE_KEYS.model) || "";
  function setOptions(list) {
    modelSel.innerHTML = "";
    for (const id of list) {
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = id;
      modelSel.appendChild(opt);
    }
    if (saved && [...modelSel.options].some(o => o.value === saved)) {
      modelSel.value = saved;
    } else if ([...modelSel.options].some(o => o.value === "gpt-5-mini")) {
      modelSel.value = "gpt-5-mini";
    } else if (modelSel.options.length) {
      modelSel.selectedIndex = 0;
    }
    saveConfig();
  }

  setOptions(fallback);
  try {
    const resp = await fetch("/models", { headers: buildConfigHeaders() });
    const j = await resp.json();
    if (!resp.ok) throw new Error(j.error || "failed to load models");
    if (Array.isArray(j.models) && j.models.length) {
      setOptions(j.models);
      logEvent(`Loaded ${j.models.length} models`);
    }
  } catch (e) {
    logEvent(`Model load fallback used: ${e.message}`);
  }
}

async function whoAmI() {
  const resp = await fetch("/whoami", { method: "GET", headers: buildConfigHeaders() });
  const data = await resp.json();
  sidEl.textContent = data.session_id || "unknown";
  cookieIdEl.textContent = data.cookie_id || data.session_id || "unknown";
  convEl.textContent = data.conversation_id || "none";
}

async function hydrateRecentMessages() {
  const statusConnected = supabaseStatus.classList.contains("ok");
  if (!statusConnected) {
    logEvent({ status: "warn", title: "hydrate skipped", input: "supabase disconnected", output: "no history loaded" });
    return;
  }

  try {
    const resp = await fetch("/chat-history", { method: "GET", headers: buildConfigHeaders() });
    const data = await resp.json();
    if (!resp.ok) throw new Error(data.error || "failed to load chat history");

    const history = Array.isArray(data.messages) ? data.messages : [];
    if (!history.length) {
      logEvent({ status: "ok", title: "history hydrate", input: "last 5", output: "no previous messages" });
      return;
    }

    clearChat();
    for (const msg of history) {
      if (!CHAT_ROLES.has(msg.role)) continue;
      addMsg(msg.content || "", normalizeRole(msg.role));
    }

    if (data.session_id) sidEl.textContent = data.session_id;
    if (data.conversation_id) convEl.textContent = data.conversation_id;

    logEvent({ status: "ok", title: "history hydrate", input: "last 5", output: `loaded ${history.length} message(s)` });
  } catch (e) {
    logEvent({ status: "error", title: "history hydrate", input: "last 5", output: e.message });
  }
}

async function send() {
  const text = input.value.trim();
  if (!text) return;
  saveConfig();
  addMsg(text, "user");
  input.value = "";
  sendBtn.disabled = true;

  try {
    const resp = await fetch("/chat", {
      method: "POST",
      headers: { "Content-Type": "application/json", ...buildConfigHeaders() },
      body: JSON.stringify({ message: text, channel: "web", locale: "en-IN", model: modelSel.value })
    });
    const data = await resp.json();
    if (!resp.ok) throw new Error(data.error || "Request failed");
    addMsg(data.reply, "bot");
    sidEl.textContent = data.session_id || sidEl.textContent;
    cookieIdEl.textContent = data.cookie_id || cookieIdEl.textContent;
    convEl.textContent = data.conversation_id || convEl.textContent;
    logEvent({
      status: "ok",
      title: "chat response",
      input: {
        user_text: text,
        selected_chat_model: modelSel.value,
        extracted_with_model: "gpt-4.1-mini"
      },
      output: {
        reply: data.reply,
        intent: data.intent,
        used_chat_model: data.chat_model,
        used_extraction_model: data.extraction_model
      },
      schema: {
        chat_output_schema: data.chat_output_schema || { type: "text" },
        extraction_output_schema: data.extraction_output_schema || null
      }
    });
  } catch (e) {
    addMsg("Error: " + e.message, "bot");
    logEvent({ status: "error", title: "chat response", input: text, output: e.message });
  } finally {
    sendBtn.disabled = false;
    input.focus();
    await refreshStatus();
  }
}

sendBtn.addEventListener("click", send);
[supabaseUrlInput, supabaseKeyInput, openaiKeyInput].forEach((el) => {
  el.addEventListener("input", async () => {
    saveConfig();
    await refreshStatus();
  });
});
modelSel.addEventListener("change", () => { saveConfig(); logEvent({ status: "info", title: "model selected", input: "dropdown", output: modelSel.value }); });
refreshModelsBtn.addEventListener("click", async () => { await loadModels(); });

input.addEventListener("keydown", (e) => {
  if (e.key === "Enter" && !e.shiftKey) {
    e.preventDefault();
    send();
  }
});

newSessionBtn.addEventListener("click", async () => {
  await fetch("/new-session", { method: "POST" });
  chatLog.innerHTML = "";
  addMsg("New cookie/session started.", "bot");
  logEvent("Started new session");
  await whoAmI();
});

newConversationBtn.addEventListener("click", async () => {
  const resp = await fetch("/new-conversation", { method: "POST", headers: buildConfigHeaders() });
  const data = await resp.json();
  if (!resp.ok) {
    logEvent(`Failed to start new conversation: ${data.error || 'unknown error'}`);
    return;
  }
  chatLog.innerHTML = "";
  addMsg("Started a new conversation thread.", "bot");
  logEvent("Started new conversation");
  await whoAmI();
});

(async function init() {
  loadConfig();
  await refreshStatus();
  await loadModels();
  await whoAmI();
  await hydrateRecentMessages();
  if (!chatLog.childElementCount) {
    addMsg("Hi! I can help with orders, returns, and product questions.", "bot");
  }
  logEvent({ status: "ok", title: "ui initialized", input: "startup", output: "ready" });
})();
</script>
</body>
</html>

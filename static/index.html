<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>AI Chatbot MVP</title>
  <style>
    :root {
      --bg: #f6f7fb;
      --panel: #ffffff;
      --border: #e5e7eb;
      --text: #111827;
      --muted: #6b7280;
      --good: #16a34a;
      --bad: #dc2626;
      --btn: #111827;
      --btnText: #ffffff;
      --chip: #eef2ff;
    }
    * { box-sizing: border-box; }
    body { margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; background: var(--bg); color: var(--text); }
    .wrap { height: 100vh; display: grid; grid-template-columns: 1.25fr 0.75fr; gap: 12px; padding: 12px; }
    .card { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 12px; overflow: hidden; box-shadow: 0 1px 2px rgba(0,0,0,.04); }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; }
    label { display:block; font-size: 12px; color: var(--muted); margin-bottom: 6px; }
    input, select, button { width: 100%; padding: 10px; border: 1px solid var(--border); border-radius: 10px; font-size: 14px; outline: none; background: #fff; }
    input:focus, select:focus { border-color: #c7d2fe; box-shadow: 0 0 0 3px rgba(99,102,241,.15); }
    button { background: var(--btn); color: var(--btnText); border: none; cursor: pointer; font-weight: 600; }
    button.secondary { background: #374151; }
    button.ghost { background: transparent; color: var(--text); border: 1px solid var(--border); }
    .topbar { display:flex; align-items:center; justify-content: space-between; gap:10px; margin-bottom: 10px; }
    .statusline { display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .dot { display:inline-flex; align-items:center; gap:6px; padding: 6px 10px; border-radius: 999px; background: var(--chip); font-size: 12px; color: var(--muted); }
    .dot b { color: var(--text); }
    .dot .ok { color: var(--good); font-weight: 900; }
    .dot .no { color: var(--bad); font-weight: 900; }

    .chatArea { display: grid; grid-template-rows: auto auto 1fr auto; height: calc(100vh - 24px); min-height: 0; gap: 10px; }
    .chatWindow { border: 1px solid var(--border); border-radius: 12px; padding: 10px; overflow-y: auto; background: #fbfbfe; min-height: 0; }
    .msg { margin: 8px 0; display:flex; }
    .bubble { max-width: 86%; padding: 10px 12px; border-radius: 12px; border: 1px solid var(--border); background: #fff; white-space: pre-wrap; line-height: 1.35; }
    .me { justify-content: flex-end; }
    .me .bubble { background: #eef2ff; }
    .sys { justify-content: center; }
    .sys .bubble { background: #fff7ed; }
    .composer { display: grid; grid-template-columns: 1fr 120px; gap: 10px; align-items: center; }
    .logBox { height: calc(100vh - 24px - 48px); overflow: auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px;
      background: #0b1020; color: #d1d5db; border-radius: 12px; padding: 10px; white-space: pre-wrap; line-height: 1.35; }
    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card chatArea">
      <div class="topbar">
        <div>
          <div style="font-weight:800; font-size:16px;">Ecommerce Chatbot MVP</div>
          <div class="hint">
            Keys are loaded from backend local files. Chat uses selected model; extraction forced to <b>gpt-4o-mini</b>.
          </div>
        </div>
        <div class="statusline">
          <span class="dot"><span id="s_backend" class="no">✖</span> <b>Backend</b></span>
          <span class="dot"><span id="s_openai" class="no">✖</span> <b>AI</b></span>
          <span class="dot"><span id="s_supabase" class="no">✖</span> <b>Supabase</b></span>
        </div>
      </div>

      <div class="card" style="padding:12px; margin:0;">
        <div class="row3">
          <div>
            <label>Cookie anon_id</label>
            <input id="anonId" readonly placeholder="(auto)" />
          </div>
          <div>
            <label>Session ID</label>
            <input id="sessionId" readonly placeholder="(auto)" />
          </div>
          <div>
            <label>Conversation ID</label>
            <input id="conversationId" readonly placeholder="(auto)" />
          </div>
        </div>

        <div class="row3" style="margin-top:10px;">
          <div>
            <label>Chat Model</label>
            <select id="modelSelect"><option value="">Loading…</option></select>
          </div>
          <div style="display:flex; gap:10px; align-items:end;">
            <button class="ghost" id="btnNewCookie">New Cookie</button>
            <button class="secondary" id="btnNewSession">New Session</button>
          </div>
          <div style="display:flex; gap:10px; align-items:end;">
            <button class="ghost" id="btnNewConversation">New Conversation</button>
            <button class="ghost" id="btnReload">Reconnect</button>
          </div>
        </div>

        <div class="hint">Reconnect order: Backend → Supabase test → Models → Resume messages.</div>
      </div>

      <div class="chatWindow" id="chatWindow"></div>

      <div class="composer">
        <input id="chatInput" placeholder="Type a message…" />
        <button id="btnSend">Send</button>
      </div>
    </div>

    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
        <div style="font-weight:800;">Logs</div>
        <div style="display:flex; gap:10px;">
          <button class="ghost" id="btnCopyLogs">Copy</button>
          <button class="ghost" id="btnClearLogs">Clear</button>
        </div>
      </div>
      <div class="logBox" id="logBox"></div>
    </div>
  </div>

<script>
(() => {
  const LS_KEY = "mvp_chat_state_v2";
  const BACKEND = "http://localhost:8000"; // removed from UI by design
  const ANON_COOKIE = "kandor_anon_id";

  const $ = (id) => document.getElementById(id);
  const els = {
    anonId: $("anonId"),
    sessionId: $("sessionId"),
    conversationId: $("conversationId"),
    modelSelect: $("modelSelect"),
    chatWindow: $("chatWindow"),
    chatInput: $("chatInput"),
    logBox: $("logBox"),
    s_backend: $("s_backend"),
    s_openai: $("s_openai"),
    s_supabase: $("s_supabase"),
  };
  const btns = {
    send: $("btnSend"),
    newCookie: $("btnNewCookie"),
    newSession: $("btnNewSession"),
    newConversation: $("btnNewConversation"),
    reload: $("btnReload"),
    copyLogs: $("btnCopyLogs"),
    clearLogs: $("btnClearLogs"),
  };

  function log(level, msg, obj) {
    const ts = new Date().toISOString();
    let line = `[${ts}] ${level}: ${msg}\n`;
    if (obj !== undefined) line += JSON.stringify(obj, null, 2) + "\n";
    els.logBox.textContent += line + "\n";
    els.logBox.scrollTop = els.logBox.scrollHeight;
  }

  function setStatus(el, ok) {
    el.textContent = ok ? "✔" : "✖";
    el.className = ok ? "ok" : "no";
  }

  function addMsg(role, text) {
    const wrap = document.createElement("div");
    wrap.className = "msg " + (role === "user" ? "me" : role === "system" ? "sys" : "ai");
    const bubble = document.createElement("div");
    bubble.className = "bubble";
    bubble.textContent = text;
    wrap.appendChild(bubble);
    els.chatWindow.appendChild(wrap);
    els.chatWindow.scrollTop = els.chatWindow.scrollHeight;
  }

  function clearChat() {
    els.chatWindow.innerHTML = "";
  }

  function saveState() {
    const st = {
      session_id: els.sessionId.value || null,
      conversation_id: els.conversationId.value || null,
      model: els.modelSelect.value || null,
    };
    localStorage.setItem(LS_KEY, JSON.stringify(st));
  }

  function loadState() {
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return;
    try {
      const st = JSON.parse(raw);
      if (st.session_id) els.sessionId.value = st.session_id;
      if (st.conversation_id) els.conversationId.value = st.conversation_id;
    } catch {}
  }

  function clearCookie(name) {
    document.cookie = `${name}=; Max-Age=0; path=/; samesite=lax`;
  }

  async function checkBackendHealth() {
    const url = `${BACKEND}/health`;
    try {
      const r = await fetch(url, { method:"GET", credentials:"include" });
      const ok = r.ok;
      setStatus(els.s_backend, ok);
      if (!ok) {
        log("WARN", `Backend not healthy (${r.status})`);
        return null;
      }
      const j = await r.json();
      els.anonId.value = j.anon_id || "";
      log("INFO", "Backend active (200)", j);
      return j;
    } catch (e) {
      setStatus(els.s_backend, false);
      log("WARN", "Backend not reachable.", { error: String(e) });
      return null;
    }
  }

  async function testSupabase() {
    const url = `${BACKEND}/v1/test/supabase`;
    try {
      log("INFO", `POST ${url}`);
      const r = await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ table:"app_users", limit: 1 }),
        credentials:"include"
      });
      const j = await r.json();
      const ok = r.ok && j.ok;
      setStatus(els.s_supabase, ok);
      if (ok) log("INFO", "Supabase test OK.", j);
      else log("ERROR", `Supabase test failed (${r.status})`, j);
      return ok;
    } catch (e) {
      setStatus(els.s_supabase, false);
      log("ERROR", "Supabase test failed", { error: String(e) });
      return false;
    }
  }

  async function loadModels() {
    const url = `${BACKEND}/v1/models`;
    try {
      log("INFO", `GET ${url}`);
      const r = await fetch(url, { credentials:"include" });
      const t = await r.text();
      if (!r.ok) throw new Error(`Models failed (${r.status}) ${t}`);
      const j = JSON.parse(t);
      const models = j.models || [];
      els.modelSelect.innerHTML = "";
      for (const m of models) {
        const opt = document.createElement("option");
        opt.value = m;
        opt.textContent = m;
        els.modelSelect.appendChild(opt);
      }
      const preferred = "gpt-5-mini";
      if (models.includes(preferred)) els.modelSelect.value = preferred;
      else if (j.default && models.includes(j.default)) els.modelSelect.value = j.default;
      else if (models.length) els.modelSelect.value = models[0];

      setStatus(els.s_openai, true);
      log("INFO", `Loaded ${models.length} models.`, { default_selected: els.modelSelect.value });
      return true;
    } catch (e) {
      setStatus(els.s_openai, false);
      log("ERROR", "AI model load failed", { error: String(e) });
      return false;
    }
  }

  async function createSessionIfNeeded() {
    if (els.sessionId.value) return true;
    const url = `${BACKEND}/v1/session`;
    log("INFO", `POST ${url}`);
    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ session_id: null, channel:"web", locale:"en" }),
      credentials:"include"
    });
    const j = await r.json();
    if (!r.ok) {
      log("ERROR", `Create session failed (${r.status})`, j);
      return false;
    }
    els.sessionId.value = j.session_id || "";
    els.conversationId.value = j.conversation_id || "";
    saveState();
    log("INFO", "Session created.", j);
    return true;
  }

  async function resumeConversation() {
    await createSessionIfNeeded();
    const url = `${BACKEND}/v1/conversation/latest?session_id=${encodeURIComponent(els.sessionId.value)}&limit=50`;
    log("INFO", `GET ${url}`);
    const r = await fetch(url, { credentials:"include" });
    const j = await r.json();
    if (!r.ok) {
      log("ERROR", `Resume failed (${r.status})`, j);
      addMsg("system", `Resume failed (${r.status}). Check logs.`);
      return false;
    }
    els.anonId.value = j.anon_id || els.anonId.value;
    els.sessionId.value = j.session_id || els.sessionId.value;
    els.conversationId.value = j.conversation_id || els.conversationId.value;
    saveState();

    clearChat();
    if ((j.messages || []).length === 0) {
      addMsg("system", "No prior messages (new/empty conversation).");
      return true;
    }
    addMsg("system", `Resumed conversation: ${els.conversationId.value}`);
    for (const m of j.messages) {
      if (!m || !m.content) continue;
      if (m.role === "user") addMsg("user", m.content);
      else if (m.role === "assistant") addMsg("assistant", m.content);
    }
    return true;
  }

  async function connectAll() {
    // required order: Backend → Supabase → AI → Resume
    const h = await checkBackendHealth();
    if (!h) return;

    const sbOk = await testSupabase();
    if (!sbOk) {
      addMsg("system", "Supabase connection failed. Fix supabase_url.txt/service_role.txt and restart backend.");
      return;
    }

    const aiOk = await loadModels();
    if (!aiOk) {
      addMsg("system", "AI connection failed. Fix ai_api.txt and restart backend.");
      return;
    }

    // push preferred model (optional) so backend knows default choice (no keys involved)
    try {
      const url = `${BACKEND}/v1/config`;
      await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ preferred_model: els.modelSelect.value || "gpt-5-mini" }),
        credentials:"include"
      });
    } catch {}

    await resumeConversation();
  }

  async function closeAndNewConversation() {
    if (!els.conversationId.value) {
      // if none, just resume -> will create open conversation
      await resumeConversation();
      return;
    }
    const url = `${BACKEND}/v1/conversation/close`;
    log("INFO", `POST ${url}`, { conversation_id: els.conversationId.value });
    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify({ conversation_id: els.conversationId.value }),
      credentials:"include"
    });
    const j = await r.json();
    if (!r.ok) {
      log("ERROR", `Close failed (${r.status})`, j);
      addMsg("system", `Close failed (${r.status}).`);
      return;
    }
    addMsg("system", "Conversation closed. Starting a new one…");
    els.conversationId.value = "";
    saveState();
    // this will create/open a new conversation on backend
    els.sessionId.value = ""; // new conversation typically tied to new session in your model; simplest MVP
    saveState();
    await connectAll();
  }

  async function newSession() {
    els.sessionId.value = "";
    els.conversationId.value = "";
    saveState();
    await connectAll();
  }

  async function newCookie() {
    clearCookie(ANON_COOKIE);
    localStorage.removeItem(LS_KEY);
    location.reload();
  }

  async function sendChat() {
    const text = (els.chatInput.value || "").trim();
    if (!text) return;

    if (!els.sessionId.value || !els.conversationId.value) {
      await connectAll();
      if (!els.sessionId.value || !els.conversationId.value) return;
    }

    const url = `${BACKEND}/v1/chat`;
    const payload = {
      session_id: els.sessionId.value,
      conversation_id: els.conversationId.value,
      model: els.modelSelect.value || "gpt-5-mini",
      message: text
    };

    addMsg("user", text);
    els.chatInput.value = "";
    log("INFO", `POST ${url}`, payload);

    const r = await fetch(url, {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload),
      credentials:"include"
    });
    const j = await r.json().catch(() => ({}));
    if (!r.ok) {
      log("ERROR", `Chat failed (${r.status})`, j);
      addMsg("system", `Error: ${r.status}`);
      return;
    }
    els.conversationId.value = j.conversation_id || els.conversationId.value;
    saveState();
    addMsg("assistant", j.reply || "(no reply)");
    log("INFO", "Chat success.", { chat_model: j.chat_model, extractor_model: j.extractor_model, extracted: j.extracted });
  }

  // Events
  btns.reload.addEventListener("click", connectAll);
  btns.newSession.addEventListener("click", newSession);
  btns.newConversation.addEventListener("click", closeAndNewConversation);
  btns.newCookie.addEventListener("click", newCookie);

  btns.send.addEventListener("click", sendChat);
  els.chatInput.addEventListener("keydown", (e) => { if (e.key === "Enter") sendChat(); });

  els.modelSelect.addEventListener("change", async () => {
    saveState();
    try {
      const url = `${BACKEND}/v1/config`;
      await fetch(url, {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ preferred_model: els.modelSelect.value || "gpt-5-mini" }),
        credentials:"include"
      });
      log("INFO", "Preferred model updated.", { preferred_model: els.modelSelect.value });
    } catch (e) {
      log("WARN", "Failed updating preferred model.", { error: String(e) });
    }
  });

  btns.copyLogs.addEventListener("click", async () => {
    try { await navigator.clipboard.writeText(els.logBox.textContent); log("INFO", "Copied logs to clipboard."); }
    catch (e) { log("ERROR", "Copy failed", { error: String(e) }); }
  });
  btns.clearLogs.addEventListener("click", () => { els.logBox.textContent = ""; });

  // Boot
  (async function boot() {
    loadState();
    await connectAll();
  })();
})();
</script>
</body>
</html>
